# A0162253M
###### \java\teamthree\twodo\commons\events\LoadNewModelEvent.java
``` java
// Indicates and updates when a new model is to be loaded
public class LoadNewModelEvent extends BaseEvent {

    public final ReadOnlyTaskList taskList;

    public LoadNewModelEvent(ReadOnlyTaskList taskBook) {
        this.taskList = taskBook;
    }
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\teamthree\twodo\commons\events\logic\NewUserInputEvent.java
``` java
//NewUserInputEvent to indicate that the user has typed in a new command
public class NewUserInputEvent extends BaseEvent {

    public final ArrayList<String> userInput;

    public NewUserInputEvent(ArrayList<String> userInput) {
        this.userInput = userInput;
    }

    @Override
    public String toString() {
        return "Updated List of previous user inputs for CommandBox";
    }

}
```
###### \java\teamthree\twodo\commons\events\storage\TaskListFilePathChangedEvent.java
``` java
// Indicates and updates when the file path of the task list has changed
public class TaskListFilePathChangedEvent extends BaseEvent {

    public final String filePath;

    public TaskListFilePathChangedEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\teamthree\twodo\commons\events\storage\TaskListStorageChangedEvent.java
``` java
// Indicates and updates when the storage of the task list has changed
public class TaskListStorageChangedEvent extends BaseEvent {

    public final String filePath;

    public TaskListStorageChangedEvent(String filepath) {
        this.filePath = filepath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\teamthree\twodo\logic\CommandHistory.java
``` java
// Stores the history of commands executed.
public class CommandHistory {

    //private static final Logger logger = LogsCenter.getLogger(StorageManager.class);

    private Stack<String> userInputHistory;
    private Stack<ReadOnlyTask> beforeEditHistory;
    private Stack<ReadOnlyTask> afterEditHistory;
    private Stack<ReadOnlyTask> deleteHistory;
    private Stack<ReadOnlyTask> addHistory;
    private Stack<ReadOnlyTask> markHistory;
    private Stack<ReadOnlyTask> unmarkHistory;
    private Stack<ReadOnlyTaskList> clearHistory;
    private Stack<Options> optionsHistory;
    private ArrayList<String> fullUserInputHistory;
    private Stack<ReadOnlyTaskList> delTagHistory;
    private Stack<Tag> tagDeletedHistory;
    private Stack<ReadOnlyTaskList> addTagHistory;
    private Stack<Tag> tagAddedHistory;

    public CommandHistory() {
        beforeEditHistory = new Stack<ReadOnlyTask>();
        afterEditHistory = new Stack<ReadOnlyTask>();
        addHistory = new Stack<ReadOnlyTask>();
        deleteHistory = new Stack<ReadOnlyTask>();
        markHistory = new Stack<ReadOnlyTask>();
        unmarkHistory = new Stack<ReadOnlyTask>();
        clearHistory = new Stack<ReadOnlyTaskList>();
        optionsHistory = new Stack<Options>();
        userInputHistory = new Stack<String>();
        fullUserInputHistory = new ArrayList<>();
        delTagHistory = new Stack<ReadOnlyTaskList>();
        addTagHistory = new Stack<ReadOnlyTaskList>();
        tagAddedHistory = new Stack<Tag>();
        tagDeletedHistory = new Stack<Tag>();
    }

    /**
     * Appends {@code userInput} to the list of user input entered.
     */
    public void add(String userInput) {
        requireNonNull(userInput);
        fullUserInputHistory.add(userInput);
        EventsCenter.getInstance().post(new NewUserInputEvent(this.getHistory()));
    }

    /**
     * Returns a defensive copy of {@code userInputHistory}.
     */
    public ArrayList<String> getHistory() {
        return new ArrayList<String>(fullUserInputHistory);
    }

    /**
     * Appends {@code userInput} to the list of user input entered.
     */
    public void addToUserInputHistory(String userInput) throws ParseException {
        requireNonNull(userInput);
        String[] arguments = seperateInput(userInput);
        boolean isUndoRedo = arguments[0].equals(RedoCommand.COMMAND_WORD)
                || arguments[0].equals(RedoCommand.COMMAND_WORD_FAST)
                || arguments[0].equals(UndoCommand.COMMAND_WORD)
                || arguments[0].equals(UndoCommand.COMMAND_WORD_FAST);

        if (!isUndoRedo) {
            boolean isDeleteCommandWord = arguments[0].equals(DeleteCommand.COMMAND_WORD)
                    || arguments[0].equals(DeleteCommand.COMMAND_WORD_QUICK)
                    || arguments[0].equals(DeleteCommand.COMMAND_WORD_SHORT)
                    || arguments[0].equals(DeleteCommand.COMMAND_WORD_FAST);

            boolean isAddCommandWord = arguments[0].equals(AddCommand.COMMAND_WORD)
                    || arguments[0].equals(AddCommand.COMMAND_WORD_QUICK)
                    || arguments[0].equals(AddCommand.COMMAND_WORD_FAST);

            if (isDeleteCommandWord) {
                organiseDeleteCommandInput(arguments);
            } else if (isAddCommandWord) {
                organiseAddCommandInput(arguments);
            } else {
                getUserInputHistory().push(arguments[0]);
            }
        }
    }

    private void organiseAddCommandInput(String[] arguments) {
        String[] splitArgs = arguments[1].trim().split(" ");
        boolean isAddTag = splitArgs.length > 1
            && splitArgs[0].trim().equals(PREFIX_CATEGORY.toString());

        if (isAddTag) {
            getUserInputHistory().push(UndoCommand.ADD_TAG);
        } else {
            getUserInputHistory().push(arguments[0]);
        }
    }

    private void organiseDeleteCommandInput(String[] arguments) {
        String[] splitArgs = arguments[1].trim().split(" ");
        boolean isDeleteTag = splitArgs.length > 1
            && splitArgs[0].trim().equals(PREFIX_CATEGORY.toString());

        if (isDeleteTag) {
            getUserInputHistory().push(UndoCommand.DELETE_TAG);
        } else {
            getUserInputHistory().push(arguments[0]);
        }
    }

    /**
     * Appends {@code task} to the list of task before edits entered.
     */
    public void addToBeforeEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        beforeEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of task after edits entered.
     */
    public void addToAfterEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        afterEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of added tasks entered.
     */
    public void addToAddHistory(ReadOnlyTask task) {
        requireNonNull(task);
        addHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of deleted tasks entered.
     */
    public void addToDeleteHistory(ReadOnlyTask task) {
        requireNonNull(task);
        deleteHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of marked tasks entered.
     */
    public void addToMarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        markHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of unmarked tasks entered.
     */
    public void addToUnmarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        unmarkHistory.push(task);
    }

    /**
     * Appends {@code filePath} to the list of cleared filePath entered.
     */
    public void addToClearHistory(ReadOnlyTaskList taskBook) {
        requireNonNull(taskBook);
        clearHistory.push(taskBook);
    }

    /**
     * Appends {@code option} to the list of options edits entered.
     */
    public void addToOptionsHistory(Options option) {
        requireNonNull(option);
        optionsHistory.push(option);
    }
    /**
     * Appends {@code taskList} to the list of taskList changed due to deleting tags.
     */
    public void addToDelTagHistory(ReadOnlyTaskList taskList) {
        requireNonNull(taskList);
        delTagHistory.push(taskList);
    }

    /**
     * Appends {@code tag} to the list of tags deleted.
     */
    public void addToTagDeletedHistory(Tag tag) {
        requireNonNull(tag);
        tagDeletedHistory.push(tag);
    }

    /**
     * Appends {@code taskList} to the list of taskList changed due to added tags.
     */
    public void addToAddTagHistory(ReadOnlyTaskList taskList) {
        requireNonNull(taskList);
        addTagHistory.push(taskList);
    }

    /**
     * Appends {@code tag} to the list of tags added.
     */
    public void addToTagAddedHistory(Tag tag) {
        requireNonNull(tag);
        tagAddedHistory.push(tag);
    }

    public Stack<String> getUserInputHistory() {
        requireNonNull(userInputHistory);
        return userInputHistory;
    }

    public Stack<ReadOnlyTask> getBeforeEditHistory() {
        requireNonNull(beforeEditHistory);
        return beforeEditHistory;
    }

    public Stack<ReadOnlyTask> getAfterEditHistory() {
        requireNonNull(afterEditHistory);
        return afterEditHistory;
    }

    public Stack<ReadOnlyTask> getAddHistory() {
        requireNonNull(addHistory);
        return addHistory;
    }

    public Stack<ReadOnlyTask> getDeleteHistory() {
        requireNonNull(deleteHistory);
        return deleteHistory;
    }

    public Stack<ReadOnlyTask> getMarkHistory() {
        requireNonNull(markHistory);
        return markHistory;
    };

    public Stack<ReadOnlyTask> getUnmarkHistory() {
        requireNonNull(unmarkHistory);
        return unmarkHistory;
    }

    public Stack<ReadOnlyTaskList> getClearHistory() {
        requireNonNull(clearHistory);
        return clearHistory;
    }

    public Stack<Options> getOptionsHistory() {
        requireNonNull(optionsHistory);
        return optionsHistory;
    }

    public Stack<ReadOnlyTaskList> getDelTagHistory() {
        requireNonNull(delTagHistory);
        return delTagHistory;
    }

    public Stack<Tag> getTagDeletedHistory() {
        requireNonNull(tagDeletedHistory);
        return tagDeletedHistory;
    }

    public Stack<ReadOnlyTaskList> getAddTagHistory() {
        requireNonNull(addTagHistory);
        return addTagHistory;
    }

    public Stack<Tag> getTagAddedHistory() {
        requireNonNull(tagAddedHistory);
        return tagAddedHistory;
    }


    private String[] seperateInput(String userInput) throws ParseException {
        final Matcher matcher = Parser.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String args = matcher.group("arguments");
        String[] result = {commandWord, args};
        return result;
    }
}
```
###### \java\teamthree\twodo\logic\commands\LoadCommand.java
``` java
// Load TaskList to the specified directory
public class LoadCommand extends Command {

    public static final String COMMAND_WORD = "load";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Load the TaskList from a particular file into 2Do."
            + "To view the changes, after typing load command, enter exit command and reopen 2Do."
            + "FILE_PATH/FILENAME.xml\n" + "Example for Windows: C:/Users/Desktop/2Do.xml\n"
            + "Example for Mac: /User/Username/Desktop/2Do.xml\n";

    public static final String MESSAGE_SUCCESS = "File %1$s successfully loaded\n ";
    public static final String MESSAGE_INVALID_PATH = "File Path %1$s is invalid\n";
    public static final String MESSAGE_FAILURE = "Failed to load file %1$s\n";
    private static final String XML = ".xml";
    public final String filePath;

    public LoadCommand(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() throws CommandException {
        //Ensure file is a Xml File
        if (!isXml(filePath)) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
        try {
            EventsCenter.getInstance().post(new LoadCommandExecutedEvent(filePath));
            return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
        } catch (InvalidPathException e) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
    }

    private boolean isXml(String filePath) {
        return filePath.endsWith(XML);
    }
}
```
###### \java\teamthree\twodo\logic\commands\RedoCommand.java
``` java
// Redoes the function that was undone in the previous command
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String COMMAND_WORD_FAST = "r";
    public static final String MESSAGE_SUCCESS = "Successfully redid command.\n";
    public static final String MESSAGE_NO_HISTORY = "Failed to redo: You have not yet entered any undo commands.";
    public static final String MESSAGE_INVALID_PREVIOUS_COMMAND = "Failed to redo: Invalid previous command ";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redoes the previous undone command.";

    private static String fullMessage;

    @Override
    public CommandResult execute() throws CommandException {
        if (undoHistory.getUserInputHistory().isEmpty()) {
            return new CommandResult(MESSAGE_NO_HISTORY);
        }

        CommandResult redoResult = null;
        try {
            redoResult = processUndoCommand();
        } catch (DuplicateTaskException e) {
            throw new CommandException(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (ParseException e) {
            assert false : "The Command called previously is invalid";
        }

        return redoResult;
    }

    private CommandResult processUndoCommand() throws TaskNotFoundException, DuplicateTaskException, ParseException {
        final String previousCommandWord = undoHistory.getUserInputHistory().pop();
        history.addToUserInputHistory(previousCommandWord);

        switch (previousCommandWord) {

        case DeleteCommand.COMMAND_WORD:
        case DeleteCommand.COMMAND_WORD_QUICK:
        case DeleteCommand.COMMAND_WORD_FAST:
        case DeleteCommand.COMMAND_WORD_SHORT:
            return redoDeleteCommand();

        case UndoCommand.DELETE_TAG:
            return redoDeleteTagCommand();

        case UndoCommand.ADD_TAG:
            return redoAddTagCommand();

        case EditCommand.COMMAND_WORD:
        case EditCommand.COMMAND_WORD_FAST:
            return redoEditCommand();

        case AddCommand.COMMAND_WORD_QUICK:
        case AddCommand.COMMAND_WORD_FAST:
        case AddCommand.COMMAND_WORD:
            return redoAddCommand();

        case ClearCommand.COMMAND_WORD:
            return redoClearCommand();

        case UnmarkCommand.COMMAND_WORD:
        case UnmarkCommand.COMMAND_WORD_FAST:
            return redoUnmarkCommand();

        case MarkCommand.COMMAND_WORD:
        case MarkCommand.COMMAND_WORD_FAST:
            return redoMarkCommand();

        case OptionsCommand.COMMAND_WORD:
        case OptionsCommand.COMMAND_WORD_FAST:
            return redoOptionsCommand();

        default:
            String message = MESSAGE_INVALID_PREVIOUS_COMMAND.concat(previousCommandWord);
            return new CommandResult(message);
        }
    }

    /**
     * Restores options settings that was undone previously and stores {@code edittedOptions} for UndoCommand
     */
    private CommandResult redoOptionsCommand() {
        Options edittedOptions = undoHistory.getOptionsHistory().pop();
        assert edittedOptions != null;
        history.addToOptionsHistory(edittedOptions);
        Options currentOptions = updateOptions(edittedOptions);
        fullMessage = MESSAGE_SUCCESS.concat(OptionsCommand.MESSAGE_UPDATE_OPTIONS_SUCCESS);
        return new CommandResult(String.format(fullMessage, currentOptions));
    }

    /**
     * Mark a task that was previously unmark due to undoCommand and stores {@code taskToMark} for the next UndoCommand
     */
    private CommandResult redoMarkCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToMark = undoHistory.getUnmarkHistory().pop();
        history.addToMarkHistory(taskToMark);
        model.markTask(taskToMark);
        fullMessage = MESSAGE_SUCCESS.concat(MarkCommand.MESSAGE_MARK_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToMark));
    }

    /**
     * Unmark a task that was previously mark due to undoCommand
     * and stores {@code taskToUnmark} for the next UndoCommand
     */
    private CommandResult redoUnmarkCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToUnmark = undoHistory.getMarkHistory().pop();
        history.addToUnmarkHistory(taskToUnmark);
        model.unmarkTask(taskToUnmark);
        fullMessage = MESSAGE_SUCCESS.concat(UnmarkCommand.MESSAGE_UNMARK_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToUnmark));
    }

    /**
     * Clears taskList that was previously restored due to a undoCommand
     * and stores the current TaskList for the next UndoCommand
     */
    private CommandResult redoClearCommand() {
        history.addToClearHistory(new TaskList(model.getTaskList()));
        model.resetData(new TaskList());
        fullMessage = MESSAGE_SUCCESS.concat(ClearCommand.MESSAGE_SUCCESS);
        return new CommandResult(fullMessage);
    }

    /**
     * Add task that was previously deleted due to a undoCommand and stores {@code taskToAdd} for the next UndoCommand
     */
    private CommandResult redoAddCommand() throws DuplicateTaskException {
        ReadOnlyTask taskToAdd = undoHistory.getDeleteHistory().pop();
        history.addToAddHistory(taskToAdd);
        model.addTask(taskToAdd);
        fullMessage = MESSAGE_SUCCESS.concat(AddCommand.MESSAGE_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToAdd));
    }

    /**
     * Restores the task that was edited due to a previous undoCommand and
     * stores {@code taskToEdit} and {@code currentTask} for the next UndoCommand
     */
    private CommandResult redoEditCommand() throws DuplicateTaskException, TaskNotFoundException {
        ReadOnlyTask taskToEdit = undoHistory.getBeforeEditHistory().pop();
        ReadOnlyTask currentTask = undoHistory.getAfterEditHistory().pop();
        history.addToBeforeEditHistory(currentTask);
        history.addToAfterEditHistory(taskToEdit);
        model.updateTask(currentTask, taskToEdit);
        fullMessage = MESSAGE_SUCCESS.concat(EditCommand.MESSAGE_EDIT_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToEdit));
    }

    /**
     * Delete tag that was previously added due to a undoCommand
     * and stores {@code tag} and {@code taskList} for the next UndoCommand
     */
    private CommandResult redoDeleteTagCommand() {
        ReadOnlyTaskList taskList = undoHistory.getDelTagHistory().pop();
        Tag tag = undoHistory.getTagDeletedHistory().pop();
        history.addToDelTagHistory(new TaskList(model.getTaskList())); //Store current model b4 tag is deleted
        history.addToTagDeletedHistory(tag); //Store Tag for UndoCommand
        model.resetData(taskList);
        fullMessage = MESSAGE_SUCCESS.concat(String.format(DeleteCommand.MESSAGE_DELETE_TAG_SUCCESS, tag.tagName));
        return new CommandResult(fullMessage);
    }

    /**
     * Add tag that was previously deleted due to a undoCommand
     * and stores {@code tag} and {@code taskList} for the next UndoCommand
     */
    private CommandResult redoAddTagCommand() {
        ReadOnlyTaskList taskList = undoHistory.getAddTagHistory().pop();
        Tag tag = undoHistory.getTagAddedHistory().pop();
        history.addToAddTagHistory(new TaskList(model.getTaskList())); //Store current model b4 tag is added
        history.addToTagAddedHistory(tag); //Store Tag for UndoCommand
        model.resetData(taskList);
        fullMessage = MESSAGE_SUCCESS.concat(String.format(AddCommand.MESSAGE_SUCCESS_TAG, tag.tagName));
        return new CommandResult(fullMessage);
    }

    /**
     * Delete task that was previously added due to a undoCommand
     * and stores {@code taskToDelete} for the next UndoCommand
     */
    private CommandResult redoDeleteCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToDelete = undoHistory.getAddHistory().pop();
        history.addToDeleteHistory(taskToDelete);
        model.deleteTask(taskToDelete);
        fullMessage = MESSAGE_SUCCESS.concat(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToDelete));
    }

    /**
     * Returns a new Object Options with default alarm and automark settings
     */
    private Options getDefaultOption() {
        Alarm alarm = new Alarm(Config.defaultNotificationPeriodToString());
        AutoMark autoMark = new AutoMark(AutoMarkManager.getSetToRun());
        return new Options(alarm, autoMark);
    }

    /**
     * Update Current Options settings with {@code editedOptions}
     * @param editedOptions must not be null
     */
    private Options updateOptions(Options editedOptions) {
        Options currentOption = getDefaultOption();
        if (!editedOptions.getAlarm().equals(currentOption.getAlarm())) {
            Config.changeDefaultNotificationPeriod(editedOptions.getAlarm().getValue());
            currentOption.editAlarm(editedOptions.getAlarm());
            // Checks if the alarm updates were properly executed for both components
            assert(Config.defaultNotificationPeriodToString() == currentOption.getAlarm().getValue());
        }
        if (!editedOptions.getAutoMark().equals(currentOption.getAutoMark())) {
            AutoMarkManager.setToRun(editedOptions.getAutoMark().getValue());
            currentOption.editAutoMark(editedOptions.getAutoMark());
            // Checks if the alarm updates were properly executed for both components
            assert(AutoMarkManager.getSetToRun() == currentOption.getAutoMark().getValue());
        }
        return currentOption;
    }
}
```
###### \java\teamthree\twodo\logic\commands\SaveCommand.java
``` java
// Saves TaskList to the specified directory
public class SaveCommand extends Command {

    public static final String COMMAND_WORD = "save";
    public static final String COMMAND_WORD_FAST = "s";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Save the TaskList created with 2Do into"
            + "FILE_PATH/FILENAME.xml\n" + "Example for Windows: C:/Users/Desktop/2Do.xml\n"
            + "Example for Mac: /User/Username/Desktop/2Do.xml\n";

    public static final String MESSAGE_SUCCESS = "File is successfully saved to: %1$s\n";
    public static final String MESSAGE_INVALID_PATH = "File Path %1$s is invalid\n";
    public static final String MESSAGE_FAILURE = "Failed to save file to %1$s\n";
    private static final String XML = ".xml";
    public final String filePath;

    public SaveCommand(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (!isXml(filePath)) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
        try {
            Paths.get(filePath);
            EventsCenter.getInstance().post(new TaskListFilePathChangedEvent(filePath));
            model.saveTaskList();
            return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
        } catch (InvalidPathException e) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
    }

    private boolean isXml(String filePath) {
        return filePath.endsWith(XML);
    }
}
```
###### \java\teamthree\twodo\logic\commands\UndoCommand.java
``` java
// Undoes the previous command by the user
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_WORD_FAST = "u";
    public static final String MESSAGE_SUCCESS = "Successfully undid command.\n";
    public static final String MESSAGE_NO_HISTORY = "Failed to undo: You have not yet entered any commands. ";
    public static final String MESSAGE_INVALID_PREVIOUS_COMMAND = "Failed to undo: Invalid previous command ";
    public static final String MESSAGE_ADD_TAG_SUCCESS = "Added Tag ";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes the previous command if undoable.";

    public static final String DELETE_TAG = "tagDeleted";
    public static final String ADD_TAG = "tagAdded";

    private static String fullMessage;

    @Override
    public CommandResult execute() throws CommandException {
        if (history.getUserInputHistory().isEmpty()) {
            return new CommandResult(MESSAGE_NO_HISTORY);
        }

        CommandResult undoResult = null;
        try {
            undoResult = processUserInput();
        } catch (DuplicateTaskException e) {
            throw new CommandException(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (ParseException e) {
            assert false : "The Command is invalid";
        } catch (IllegalValueException e) {
            assert false : "The Value is illegal";
        }
        return undoResult;
    }

    private CommandResult processUserInput() throws TaskNotFoundException, IllegalValueException, CommandException {
        final String previousCommandWord = history.getUserInputHistory().pop();
        undoHistory.addToUserInputHistory(previousCommandWord); //Save CommandWord for RedoCommand

        //Process previous Command Word and undo the command
        switch (previousCommandWord) {

        case AddCommand.COMMAND_WORD:
        case AddCommand.COMMAND_WORD_QUICK:
        case AddCommand.COMMAND_WORD_FAST:
            return undoAddCommand();

        case EditCommand.COMMAND_WORD:
        case EditCommand.COMMAND_WORD_FAST:
            return undoEditCommand();

        case DeleteCommand.COMMAND_WORD_QUICK:
        case DeleteCommand.COMMAND_WORD_FAST:
        case DeleteCommand.COMMAND_WORD_SHORT:
        case DeleteCommand.COMMAND_WORD:
            return undoDeleteCommand();

        case DELETE_TAG:
            return undoDeleteTagCommand();

        case ADD_TAG:
            return undoAddTagCommand();

        case ClearCommand.COMMAND_WORD:
            return undoClearCommand();

        case MarkCommand.COMMAND_WORD:
        case MarkCommand.COMMAND_WORD_FAST:
            return undoMarkCommand();

        case UnmarkCommand.COMMAND_WORD:
        case UnmarkCommand.COMMAND_WORD_FAST:
            return undoUnmarkCommand();

        case OptionsCommand.COMMAND_WORD:
        case OptionsCommand.COMMAND_WORD_FAST:
            return undoOptionsCommand();

        default:
            //For Previous Command like find, list which cannot be undone
            String message = MESSAGE_INVALID_PREVIOUS_COMMAND.concat(previousCommandWord);
            return new CommandResult(message);
        }
    }

    /**
     * Restore previous options settings and store {@code edittedOptions} for RedoCommand
     */
    private CommandResult undoOptionsCommand() {
        undoHistory.addToOptionsHistory(getDefaultOption());
        Options edittedOptions = history.getOptionsHistory().pop();
        assert edittedOptions != null;
        Options currentOptions = updateOptions(edittedOptions);
        fullMessage = MESSAGE_SUCCESS.concat(OptionsCommand.MESSAGE_UPDATE_OPTIONS_SUCCESS);
        return new CommandResult(String.format(fullMessage, currentOptions));
    }

    private Options getDefaultOption() {
        Alarm alarm = new Alarm(Config.defaultNotificationPeriodToString());
        AutoMark autoMark = new AutoMark(AutoMarkManager.getSetToRun());
        return new Options(alarm, autoMark);
    }

    private Options updateOptions(Options editedOptions) {
        Options currentOption = getDefaultOption();
        if (!editedOptions.getAlarm().equals(currentOption.getAlarm())) {
            Config.changeDefaultNotificationPeriod(editedOptions.getAlarm().getValue());
            currentOption.editAlarm(editedOptions.getAlarm());
            // Checks if the alarm updates were properly executed for both components
            assert(Config.defaultNotificationPeriodToString() == currentOption.getAlarm().getValue());
        }
        if (!editedOptions.getAutoMark().equals(currentOption.getAutoMark())) {
            AutoMarkManager.setToRun(editedOptions.getAutoMark().getValue());
            currentOption.editAutoMark(editedOptions.getAutoMark());
            // Checks if the alarm updates were properly executed for both components
            assert(AutoMarkManager.getSetToRun() == currentOption.getAutoMark().getValue());
        }
        return currentOption;
    }

    /**
     * Mark task that was marked and store {@code taskToUnmark} for RedoCommand
     */
    private CommandResult undoUnmarkCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToMark = history.getUnmarkHistory().pop(); //Retrieve Task to mark
        undoHistory.addToMarkHistory(taskToMark); //Store Task for RedoCommand
        model.markTask(taskToMark);
        fullMessage = MESSAGE_SUCCESS.concat(MarkCommand.MESSAGE_MARK_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToMark));
    }

    /**
     * Unmark task that was marked and store {@code taskToUnmark} for RedoCommand
     */
    private CommandResult undoMarkCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToUnmark = history.getMarkHistory().pop();
        undoHistory.addToUnmarkHistory(taskToUnmark); //Store Task for RedoCommand
        model.unmarkTask(taskToUnmark);
        fullMessage = MESSAGE_SUCCESS.concat(UnmarkCommand.MESSAGE_UNMARK_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToUnmark));
    }

    /**
     * Restores Original TaskLIst before Clear Command
     */
    private CommandResult undoClearCommand() {
        ReadOnlyTaskList taskBook = history.getClearHistory().pop();
        model.resetData(taskBook);
        fullMessage = MESSAGE_SUCCESS.concat("Restored TaskList");
        return new CommandResult(fullMessage);
    }

    /**
     * Add back Deleted Tag and Stores {@code tag} and {@code taskList} for RedoCommand
     */
    private CommandResult undoDeleteTagCommand() {
        ReadOnlyTaskList taskList = history.getDelTagHistory().pop();
        Tag tag = history.getTagDeletedHistory().pop();
        undoHistory.addToDelTagHistory(new TaskList(model.getTaskList())); //Store current model b4 tag is added
        undoHistory.addToTagDeletedHistory(tag); //Store Tag for RedoCommand
        model.resetData(taskList);
        fullMessage = MESSAGE_SUCCESS.concat(String.format(AddCommand.MESSAGE_SUCCESS_TAG, tag.tagName));
        return new CommandResult(fullMessage);
    }

    /**
     * Delete back Added Tag and Stores {@code tag} and {@code taskList} for RedoCommand
     */
    private CommandResult undoAddTagCommand() {
        ReadOnlyTaskList taskList = history.getAddTagHistory().pop();
        Tag tag = history.getTagAddedHistory().pop();
        undoHistory.addToAddTagHistory(new TaskList(model.getTaskList())); //Store current model b4 tag is added
        undoHistory.addToTagAddedHistory(tag); //Store Tag for RedoCommand
        model.resetData(taskList);
        fullMessage = MESSAGE_SUCCESS.concat(String.format(DeleteCommand.MESSAGE_DELETE_TAG_SUCCESS, tag.tagName));
        return new CommandResult(fullMessage);
    }

    /**
     * Add back Deleted Task and Stores {@code taskToAdd} for RedoCommand
     */
    private CommandResult undoDeleteCommand() throws DuplicateTaskException {
        ReadOnlyTask taskToAdd = history.getDeleteHistory().pop();
        undoHistory.addToAddHistory(taskToAdd); //Store Task for RedoCommand
        model.addTask(taskToAdd);
        fullMessage = MESSAGE_SUCCESS.concat(AddCommand.MESSAGE_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToAdd));
    }

    /**
     * Restores back original Task and Stores {@code originalTask} and {@code edittedTask} for RedoCommand
     */
    private CommandResult undoEditCommand() throws DuplicateTaskException, TaskNotFoundException {
        ReadOnlyTask originalTask = history.getBeforeEditHistory().pop();
        ReadOnlyTask edittedTask = history.getAfterEditHistory().pop();
        saveTargetTaskForRedo(originalTask);
        saveEditedTargetTaskForRedo(edittedTask);
        model.updateTask(edittedTask, originalTask);
        fullMessage = MESSAGE_SUCCESS.concat(EditCommand.MESSAGE_EDIT_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, edittedTask));
    }

    /**
     * Store Target Task to be edited during RedoCommand to reverse action of this current UndoCommand
     * Create a new Task/TaskWithDeadline depending on whether the task has deadline
     * @param originalTask must not be null
     */
    private void saveTargetTaskForRedo(ReadOnlyTask originalTask) {
        assert originalTask != null;
        if (originalTask.getDeadline().isPresent()) {
            undoHistory.addToAfterEditHistory(new TaskWithDeadline(originalTask));
        } else {
            undoHistory.addToAfterEditHistory(new Task(originalTask));
        }
    }

    /**
     * Store Editted Task that should be in model after RedoCommand.
     * Create a new Task/TaskWithDeadline depending on whether the task has deadline
     * @param edittedTask must not be null
     */
    private void saveEditedTargetTaskForRedo(ReadOnlyTask edittedTask) {
        assert edittedTask != null;
        if (edittedTask.getDeadline().isPresent()) {
            undoHistory.addToBeforeEditHistory(new TaskWithDeadline(edittedTask));
        } else {
            undoHistory.addToBeforeEditHistory(new Task(edittedTask));
        }
    }

    /**
     * Deleting the task added and stores {@code taskToDelete} for RedoCommand
     */
    private CommandResult undoAddCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToDelete = history.getAddHistory().pop();
        assert taskToDelete != null;

        undoHistory.addToDeleteHistory(taskToDelete); //Store Task for RedoCommand
        model.deleteTask(taskToDelete);
        fullMessage = MESSAGE_SUCCESS.concat(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToDelete));
    }
}
```
###### \java\teamthree\twodo\logic\parser\LoadCommandParser.java
``` java
/**
 * Parses input arguments and creates a new LoadCommand object
 *
 * @throws ParseException
 *             if the user input does not conform to the expected format
 */
public class LoadCommandParser implements CommandParser {
    public LoadCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        File file = new File(trimmedArgs);
        if (!file.isDirectory()) {
            return new LoadCommand(args.trim());
        } else {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, LoadCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\teamthree\twodo\logic\parser\SaveCommandParser.java
``` java
/**
 * Parses input arguments and creates a new LoadCommand object
 *
 * @throws ParseException
 *             if the user input does not conform to the expected format
 */
public class SaveCommandParser implements CommandParser {
    public SaveCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        File file = new File(trimmedArgs);
        if (!file.isDirectory()) {
            return new SaveCommand(args.trim());
        } else {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\teamthree\twodo\logic\UndoCommandHistory.java
``` java
// Stores the history of Undo commands executed.
public class UndoCommandHistory {
    private Stack<String> userInputHistory;
    private Stack<ReadOnlyTask> beforeEditHistory;
    private Stack<ReadOnlyTask> afterEditHistory;
    private Stack<ReadOnlyTask> deleteHistory;
    private Stack<ReadOnlyTask> addHistory;
    private Stack<ReadOnlyTask> markHistory;
    private Stack<ReadOnlyTask> unmarkHistory;
    private Stack<ReadOnlyTask> undoHistory;
    private Stack<ReadOnlyTaskList> delTagHistory;
    private Stack<Tag> tagDeletedHistory;
    private Stack<ReadOnlyTaskList> addTagHistory;
    private Stack<Tag> tagAddedHistory;
    private Stack<Options> optionsHistory;

    public UndoCommandHistory() {
        beforeEditHistory = new Stack<ReadOnlyTask>();
        afterEditHistory = new Stack<ReadOnlyTask>();
        addHistory = new Stack<ReadOnlyTask>();
        deleteHistory = new Stack<ReadOnlyTask>();
        markHistory = new Stack<ReadOnlyTask>();
        unmarkHistory = new Stack<ReadOnlyTask>();
        userInputHistory = new Stack<String>();
        undoHistory = new Stack<ReadOnlyTask>();
        delTagHistory = new Stack<ReadOnlyTaskList>();
        tagDeletedHistory = new Stack<Tag>();
        addTagHistory = new Stack<ReadOnlyTaskList>();
        tagAddedHistory = new Stack<Tag>();
        optionsHistory = new Stack<Options>();
    }

    /**
     * Appends {@code userInput} to the list of user input entered.
     * @throws ParseException
     */
    public void addToUserInputHistory(String userInput) throws ParseException {
        requireNonNull(userInput);
        String commandWord = getCommandWordFromInput(userInput);
        getUserInputHistory().push(commandWord);
    }

    /**
     * Appends {@code task} to the list of task before edits entered.
     */
    public void addToBeforeEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        beforeEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of task after edits entered.
     */
    public void addToAfterEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        afterEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of added tasks entered.
     */
    public void addToAddHistory(ReadOnlyTask task) {
        requireNonNull(task);
        addHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of deleted tasks entered.
     */
    public void addToDeleteHistory(ReadOnlyTask task) {
        requireNonNull(task);
        deleteHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of marked tasks entered.
     */
    public void addToMarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        markHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of unmarked tasks entered.
     */
    public void addToUnmarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        unmarkHistory.push(task);
    }

    /**
     * Appends {@code taskList} to the list of taskList changed due to deleting tags.
     */
    public void addToDelTagHistory(ReadOnlyTaskList taskList) {
        requireNonNull(taskList);
        delTagHistory.push(taskList);
    }

    /**
     * Appends {@code tag} to the list of tags deleted.
     */
    public void addToTagDeletedHistory(Tag tag) {
        requireNonNull(tag);
        tagDeletedHistory.push(tag);
    }

    /**
     * Appends {@code taskList} to the list of taskList changed due to added tags.
     */
    public void addToAddTagHistory(ReadOnlyTaskList taskList) {
        requireNonNull(taskList);
        addTagHistory.push(taskList);
    }

    /**
     * Appends {@code tag} to the list of tags added.
     */
    public void addToTagAddedHistory(Tag tag) {
        requireNonNull(tag);
        tagAddedHistory.push(tag);
    }

    /**
     * Appends {@code option} to the list of options edits entered.
     */
    public void addToOptionsHistory(Options option) {
        requireNonNull(option);
        optionsHistory.push(option);
    }

    public Stack<String> getUserInputHistory() {
        requireNonNull(userInputHistory);
        return userInputHistory;
    }

    public Stack<ReadOnlyTask> getBeforeEditHistory() {
        requireNonNull(beforeEditHistory);
        return beforeEditHistory;
    }

    public Stack<ReadOnlyTask> getAfterEditHistory() {
        requireNonNull(afterEditHistory);
        return afterEditHistory;
    }

    public Stack<ReadOnlyTask> getAddHistory() {
        requireNonNull(addHistory);
        return addHistory;
    }

    public Stack<ReadOnlyTask> getDeleteHistory() {
        requireNonNull(deleteHistory);
        return deleteHistory;
    }

    public Stack<ReadOnlyTask> getMarkHistory() {
        requireNonNull(markHistory);
        return markHistory;
    };

    public Stack<ReadOnlyTask> getUndokHistory() {
        requireNonNull(undoHistory);
        return undoHistory;
    };

    public Stack<ReadOnlyTask> getUnmarkHistory() {
        requireNonNull(unmarkHistory);
        return unmarkHistory;
    }

    public Stack<ReadOnlyTaskList> getDelTagHistory() {
        requireNonNull(delTagHistory);
        return delTagHistory;
    }

    public Stack<Tag> getTagDeletedHistory() {
        requireNonNull(tagDeletedHistory);
        return tagDeletedHistory;
    }

    public Stack<ReadOnlyTaskList> getAddTagHistory() {
        requireNonNull(addTagHistory);
        return addTagHistory;
    }

    public Stack<Tag> getTagAddedHistory() {
        requireNonNull(tagAddedHistory);
        return tagAddedHistory;
    }

    public Stack<Options> getOptionsHistory() {
        requireNonNull(optionsHistory);
        return optionsHistory;
    }

    private String getCommandWordFromInput(String userInput) throws ParseException {
        final Matcher matcher = Parser.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        return commandWord;
    }
}
```
###### \java\teamthree\twodo\storage\StorageManager.java
``` java
    public void setTaskListFilePath(String filePath) throws IOException {
        taskListStorage.setTaskListFilePath(filePath);
        config.setTaskListFilePath(filePath);
        ConfigUtil.saveConfig(config, Config.getDefaultConfigFile());
        raise(new TaskListStorageChangedEvent(filePath));
    }

    @Override
    public Optional<ReadOnlyTaskList> readTaskList() throws DataConversionException, IOException {
        return readTaskList(taskListStorage.getTaskListFilePath());
    }

    @Override
    public Optional<ReadOnlyTaskList> readTaskList(String filePath) throws DataConversionException, IOException {
        logger.fine("Attempting to read data from file: " + filePath);
        return taskListStorage.readTaskList(filePath);
    }

    @Override
    public void saveTaskList(ReadOnlyTaskList taskList) throws IOException {
        saveTaskList(taskList, taskListStorage.getTaskListFilePath());
    }

    @Override
    public void saveTaskList(ReadOnlyTaskList taskList, String filePath) throws IOException {
        logger.fine("Attempting to write to data file: " + filePath);
        taskListStorage.saveTaskList(taskList, filePath);
    }

    public void saveNotifiedTasks(HashSet<ReadOnlyTask> notified, String filePath) throws IOException {
        logger.fine("Attempting to write to data file: " + filePath);
    }

    @Override
    @Subscribe
    public void handleTaskListChangedEvent(TaskListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveTaskList(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    @Subscribe
    private void handleTaskListFilePathChangedEvent(TaskListFilePathChangedEvent event) throws CommandException {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local filePath changed, saving to config"));
        try {
            setTaskListFilePath(event.filePath);
        } catch (IOException e) {
            throw new CommandException(String.format(SaveCommand.MESSAGE_INVALID_PATH, event.filePath));
        }
    }

    @Subscribe
    public void handleLoadCommandExecutedEvent(LoadCommandExecutedEvent event) throws CommandException {
        logger.info(
                LogsCenter.getEventHandlingLogMessage(event, "Load command executed, saving new filepath to config"));
        try {
            Optional<ReadOnlyTaskList> loadedTaskList;
            if ((loadedTaskList = readTaskList(event.filePath)).isPresent()) {
                setTaskListFilePath(event.filePath);
                raise(new LoadNewModelEvent(loadedTaskList.get()));
            }
        } catch (IOException e) {
            throw new CommandException(String.format(SaveCommand.MESSAGE_INVALID_PATH, event.filePath));
        } catch (DataConversionException e) {
            throw new CommandException(Messages.MESSAGE_LOAD_FAILED);
        }
    }
}
```
###### \java\teamthree\twodo\ui\CommandBox.java
``` java
    @FXML
    private void handleKeyPressed(KeyEvent e) {
        if (e.getCode().equals(KeyCode.UP)) {
            accessPreviousCommand();
        } else if (e.getCode().equals(KeyCode.DOWN)) {
            accessNextCommand();
        }
    }

    // Displays the previous command input on the command box if it is available
    private void accessPreviousCommand() {
        if (index > 0) {
            index--;
            commandTextField.clear();
            commandTextField.appendText(previousUserInput.get(index));
        }
    }

    private void accessNextCommand() {
        if (index < previousUserInput.size() - 1) {
            index++;
            commandTextField.clear();
            commandTextField.appendText(previousUserInput.get(index));
        }
    }
    public void setPreviousUserInput(ArrayList<String> newUserInputList) {
        previousUserInput = newUserInputList;
    }

    //Sets the command box style to indicate a successful command.
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
    }

    //Sets the command box style to indicate a failed command.
    private void setStyleToIndicateCommandFailure() {
        ObservableList<String> styleClass = commandTextField.getStyleClass();

        if (styleClass.contains(ERROR_STYLE_CLASS)) {
            return;
        }

        styleClass.add(ERROR_STYLE_CLASS);
    }

    public void handleNewUserInputEvent(NewUserInputEvent e) {
        this.setPreviousUserInput(e.userInput);
        index = e.userInput.size();
    }

}
```
###### \java\teamthree\twodo\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleTaskListStorageChangedEvent(TaskListStorageChangedEvent e) {
        logger.info(LogsCenter.getEventHandlingLogMessage(e, "Task List saved to " + e.filePath));
        setSaveLocation(e.filePath);
    }
}
```
###### \java\teamthree\twodo\ui\UiManager.java
``` java
    @Subscribe
    public void handleNewUserInputEvent(NewUserInputEvent e) {
        mainWindow.getCommandBox().handleNewUserInputEvent(e);
    }

}
```
