# A0162253M
###### \java\teamthree\twodo\commons\events\LoadNewModelEvent.java
``` java
// Indicates and updates when a new model is to be loaded
public class LoadNewModelEvent extends BaseEvent {

    public final ReadOnlyTaskList taskList;

    public LoadNewModelEvent(ReadOnlyTaskList taskBook) {
        this.taskList = taskBook;
    }
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\teamthree\twodo\commons\events\logic\NewUserInputEvent.java
``` java
//NewUserInputEvent to indicate that the user has typed in a new command
public class NewUserInputEvent extends BaseEvent {

    public final ArrayList<String> userInput;

    public NewUserInputEvent(ArrayList<String> userInput) {
        this.userInput = userInput;
    }

    @Override
    public String toString() {
        return "Updated List of previous user inputs for CommandBox";
    }

}
```
###### \java\teamthree\twodo\commons\events\storage\TaskListFilePathChangedEvent.java
``` java
// Indicates and updates when the file path of the task list has changed
public class TaskListFilePathChangedEvent extends BaseEvent {

    public final String filePath;

    public TaskListFilePathChangedEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\teamthree\twodo\commons\events\storage\TaskListStorageChangedEvent.java
``` java
// Indicates and updates when the storage of the task list has changed
public class TaskListStorageChangedEvent extends BaseEvent {

    public final String filePath;

    public TaskListStorageChangedEvent(String filepath) {
        this.filePath = filepath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\teamthree\twodo\logic\CommandHistory.java
``` java
// Stores the history of commands executed.
public class CommandHistory {

    //private static final Logger logger = LogsCenter.getLogger(StorageManager.class);

    private Stack<String> userInputHistory;
    private Stack<ReadOnlyTask> beforeEditHistory;
    private Stack<ReadOnlyTask> afterEditHistory;
    private Stack<ReadOnlyTask> deleteHistory;
    private Stack<ReadOnlyTask> addHistory;
    private Stack<ReadOnlyTask> markHistory;
    private Stack<ReadOnlyTask> unmarkHistory;
    private Stack<ReadOnlyTaskList> clearHistory;
    private Stack<Options> optionsHistory;
    private ArrayList<String> fullUserInputHistory;
    private Stack<ReadOnlyTaskList> delTagHistory;
    private Stack<Tag> tagHistory;

    public CommandHistory() {
        beforeEditHistory = new Stack<ReadOnlyTask>();
        afterEditHistory = new Stack<ReadOnlyTask>();
        addHistory = new Stack<ReadOnlyTask>();
        deleteHistory = new Stack<ReadOnlyTask>();
        markHistory = new Stack<ReadOnlyTask>();
        unmarkHistory = new Stack<ReadOnlyTask>();
        clearHistory = new Stack<ReadOnlyTaskList>();
        optionsHistory = new Stack<Options>();
        userInputHistory = new Stack<String>();
        fullUserInputHistory = new ArrayList<>();
        delTagHistory = new Stack<ReadOnlyTaskList>();
        tagHistory = new Stack<Tag>();
    }

    /**
     * Appends {@code userInput} to the list of user input entered.
     */
    public void add(String userInput) {
        requireNonNull(userInput);
        fullUserInputHistory.add(userInput);
        EventsCenter.getInstance().post(new NewUserInputEvent(this.getHistory()));
    }

    /**
     * Returns a defensive copy of {@code userInputHistory}.
     */
    public ArrayList<String> getHistory() {
        return new ArrayList<String>(fullUserInputHistory);
    }

    /**
     * Appends {@code userInput} to the list of user input entered.
     *
     * @throws ParseException
     */
    public void addToUserInputHistory(String userInput) throws ParseException {
        requireNonNull(userInput);
        String[] arguments = seperateInput(userInput);
        boolean isUndoRedo = arguments[0].equals(RedoCommand.COMMAND_WORD)
                || arguments[0].equals(RedoCommand.COMMAND_WORD_FAST)
                || arguments[0].equals(UndoCommand.COMMAND_WORD)
                || arguments[0].equals(UndoCommand.COMMAND_WORD_FAST);

        if (!isUndoRedo) {
            boolean isDeleteCommandWord = arguments[0].equals(DeleteCommand.COMMAND_WORD)
                    || arguments[0].equals(DeleteCommand.COMMAND_WORD_QUICK)
                    || arguments[0].equals(DeleteCommand.COMMAND_WORD_SHORT)
                    || arguments[0].equals(DeleteCommand.COMMAND_WORD_FAST);

            if (isDeleteCommandWord) {
                String[] splitArgs = arguments[1].trim().split(" ");
                boolean isDeleteTag = splitArgs.length > 1
                    && splitArgs[0].trim().equals(PREFIX_CATEGORY.toString());

                if (isDeleteTag) {
                    getUserInputHistory().push(PREFIX_CATEGORY.toString());
                } else {
                    getUserInputHistory().push(arguments[0]);
                }
            } else {
                getUserInputHistory().push(arguments[0]);
            }
        }
    }

    /**
     * Appends {@code task} to the list of task before edits entered.
     */
    public void addToBeforeEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        beforeEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of task after edits entered.
     */
    public void addToAfterEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        afterEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of added tasks entered.
     */
    public void addToAddHistory(ReadOnlyTask task) {
        requireNonNull(task);
        addHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of deleted tasks entered.
     */
    public void addToDeleteHistory(ReadOnlyTask task) {
        requireNonNull(task);
        deleteHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of marked tasks entered.
     */
    public void addToMarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        markHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of unmarked tasks entered.
     */
    public void addToUnmarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        unmarkHistory.push(task);
    }

    /**
     * Appends {@code filePath} to the list of cleared filePath entered.
     */
    public void addToClearHistory(ReadOnlyTaskList taskBook) {
        requireNonNull(taskBook);
        clearHistory.push(taskBook);
    }

    /**
     * Appends {@code option} to the list of options edits entered.
     */
    public void addToOptionsHistory(Options option) {
        requireNonNull(option);
        optionsHistory.push(option);
    }

    public void addToDelTagHistory(ReadOnlyTaskList taskList) {
        requireNonNull(taskList);
        delTagHistory.push(taskList);
    }

    public void addToTagHistory(Tag tag) {
        requireNonNull(tag);
        tagHistory.push(tag);
    }

    public Stack<String> getUserInputHistory() {
        requireNonNull(userInputHistory);
        return userInputHistory;
    }

    public Stack<ReadOnlyTask> getBeforeEditHistory() {
        requireNonNull(beforeEditHistory);
        return beforeEditHistory;
    }

    public Stack<ReadOnlyTask> getAfterEditHistory() {
        requireNonNull(afterEditHistory);
        return afterEditHistory;
    }

    public Stack<ReadOnlyTask> getAddHistory() {
        requireNonNull(addHistory);
        return addHistory;
    }

    public Stack<ReadOnlyTask> getDeleteHistory() {
        requireNonNull(deleteHistory);
        return deleteHistory;
    }

    public Stack<ReadOnlyTask> getMarkHistory() {
        requireNonNull(markHistory);
        return markHistory;
    };

    public Stack<ReadOnlyTask> getUnmarkHistory() {
        requireNonNull(unmarkHistory);
        return unmarkHistory;
    }

    public Stack<ReadOnlyTaskList> getClearHistory() {
        requireNonNull(clearHistory);
        return clearHistory;
    }

    public Stack<ReadOnlyTaskList> getDelTagHistory() {
        requireNonNull(delTagHistory);
        return delTagHistory;
    }

    public Stack<Tag> getTagHistory() {
        requireNonNull(tagHistory);
        return tagHistory;
    }

    private String[] seperateInput(String userInput) throws ParseException {
        final Matcher matcher = Parser.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String args = matcher.group("arguments");
        String[] result = {commandWord, args};
        return result;
    }
}
```
###### \java\teamthree\twodo\logic\commands\DeleteCommand.java
``` java
// Deletes a task identified using its last displayed index from the TaskList.
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";
    public static final String COMMAND_WORD_QUICK = "-";
    public static final String COMMAND_WORD_FAST = "d";
    public static final String COMMAND_WORD_SHORT = "del";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task or tag identified by the index number used in the last task listing.\n"
            + "Parameters: [tag] INDEX (must be a positive integer)\n"
            + "Example for Deleting Task: " + COMMAND_WORD + " 1\n"
            + "Example for Deleting Task: " + COMMAND_WORD + "tag 1\n";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    public static final String MESSAGE_DELETE_TAG_SUCCESS = "Deleted Tag: %1$s";

    public final Index targetIndex;
    public final boolean deleteCategoryFlag;

    public DeleteCommand(Index targetIndex, boolean categoryOp) {
        this.targetIndex = targetIndex;
        this.deleteCategoryFlag = categoryOp;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (deleteCategoryFlag) {
            if (targetIndex.getZeroBased() >= catMan.getCategoryList().size()) {
                throw new CommandException(Messages.MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
            } else if (targetIndex.getZeroBased() <= CategoryManager.INDEX_LAST_DEFAULT.getZeroBased()) {
                throw new CommandException(Messages.MESSAGE_DEFAULT_TAG_INDEX);
            }
            try {
                history.addToDelTagHistory(new TaskList(model.getTaskList()));
                Tag toDel = catMan.deleteCategory(targetIndex);
                history.addToTagHistory(toDel);
                return new CommandResult(String.format(MESSAGE_DELETE_TAG_SUCCESS, toDel.tagName));
            } catch (IllegalValueException e) {
                //impossible to get this exception
                e.printStackTrace();
            }
            return new CommandResult("Delete category failed.");
        }

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredAndSortedTaskList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex.getZeroBased());

        try {
            model.deleteTask(taskToDelete);
            history.addToDeleteHistory(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### \java\teamthree\twodo\logic\commands\LoadCommand.java
``` java
// Load TaskList to the specified directory
public class LoadCommand extends Command {

    public static final String COMMAND_WORD = "load";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Load the TaskList from a particular file into 2Do."
            + "To view the changes, after typing load command, enter exit command and reopen 2Do."
            + "FILE_PATH/FILENAME.xml\n" + "Example: (WINDOWS) C:/Users/Desktop/2Do.xml\n"
            + " Example: (MAC) /User/Username/Desktop/2Do.xml\n";

    public static final String MESSAGE_SUCCESS = "File %1$s successfully loaded\n ";
    public static final String MESSAGE_INVALID_PATH = "File Path %1$s is invalid\n";
    public static final String MESSAGE_FAILURE = "Failed to load file %1$s\n";
    private static final String XML = ".xml";
    public final String filePath;

    public LoadCommand(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() throws CommandException {
        //Ensure file is a Xml File
        if (!isXml(filePath)) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
        try {
            EventsCenter.getInstance().post(new LoadCommandExecutedEvent(filePath));
            return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
        } catch (InvalidPathException e) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
    }

    private boolean isXml(String filePath) {
        return filePath.endsWith(XML);
    }
}
```
###### \java\teamthree\twodo\logic\commands\RedoCommand.java
``` java
// Redoes the function that was undone in the previous command
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String COMMAND_WORD_FAST = "r";
    public static final String MESSAGE_SUCCESS = "Successfully redid command!!!\n";
    public static final String MESSAGE_NO_HISTORY = "Failed to redo: You have not yet entered any undo commands.";
    public static final String MESSAGE_INVALID_PREVIOUS_COMMAND = "Failed to redo: Invalid previous command ";

    private static String fullMessage;

    @Override
    public CommandResult execute() throws CommandException {
        if (undoHistory.getUserInputHistory().isEmpty()) {
            return new CommandResult(MESSAGE_NO_HISTORY);
        }

        CommandResult redoResult = null;
        try {
            redoResult = processUndoCommand();
        } catch (DuplicateTaskException e) {
            throw new CommandException(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (ParseException e) {
            assert false : "The Command called previously is invalid";
        }

        return redoResult;
    }

    private CommandResult processUndoCommand() throws TaskNotFoundException, DuplicateTaskException, ParseException {
        final String previousCommandWord = undoHistory.getUserInputHistory().pop();
        history.addToUserInputHistory(previousCommandWord);

        switch (previousCommandWord) {

        case DeleteCommand.COMMAND_WORD:
        case DeleteCommand.COMMAND_WORD_QUICK:
        case DeleteCommand.COMMAND_WORD_FAST:
        case DeleteCommand.COMMAND_WORD_SHORT:
            ReadOnlyTask taskToDelete = undoHistory.getAddHistory().pop();
            history.addToDeleteHistory(taskToDelete);
            model.deleteTask(taskToDelete);
            fullMessage = MESSAGE_SUCCESS.concat(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS);
            return new CommandResult(String.format(fullMessage, taskToDelete));

        case UndoCommand.DELETE_TAG:
            ReadOnlyTaskList taskList = undoHistory.getDelTagHistory().pop();
            Tag tag = undoHistory.getTagHistory().pop();
            model.resetData(taskList);
            fullMessage = MESSAGE_SUCCESS.concat(String.format(DeleteCommand.MESSAGE_DELETE_TAG_SUCCESS, tag.tagName));
            return new CommandResult(fullMessage);

        case EditCommand.COMMAND_WORD:
            ReadOnlyTask taskToEdit = undoHistory.getBeforeEditHistory().pop();
            ReadOnlyTask currentTask = undoHistory.getAfterEditHistory().pop();
            history.addToBeforeEditHistory(currentTask);
            history.addToAfterEditHistory(taskToEdit);
            model.updateTask(currentTask, taskToEdit);
            fullMessage = MESSAGE_SUCCESS.concat(EditCommand.MESSAGE_EDIT_TASK_SUCCESS);
            return new CommandResult(String.format(fullMessage, taskToEdit));

        case AddCommand.COMMAND_WORD_QUICK:
        case AddCommand.COMMAND_WORD_FAST:
        case AddCommand.COMMAND_WORD:
            ReadOnlyTask taskToAdd = undoHistory.getDeleteHistory().pop();
            history.addToAddHistory(taskToAdd);
            model.addTask(taskToAdd);
            fullMessage = MESSAGE_SUCCESS.concat(AddCommand.MESSAGE_SUCCESS);
            return new CommandResult(String.format(fullMessage, taskToAdd));

        case ClearCommand.COMMAND_WORD:
            model.resetData(new TaskList());
            fullMessage = MESSAGE_SUCCESS.concat(ClearCommand.MESSAGE_SUCCESS);
            return new CommandResult(fullMessage);

        case UnmarkCommand.COMMAND_WORD:
        case UnmarkCommand.COMMAND_WORD_FAST:
            ReadOnlyTask taskToUnmark = undoHistory.getMarkHistory().pop();
            history.addToUnmarkHistory(taskToUnmark);
            model.unmarkTask(taskToUnmark);
            fullMessage = MESSAGE_SUCCESS.concat(UnmarkCommand.MESSAGE_UNMARK_TASK_SUCCESS);
            return new CommandResult(String.format(fullMessage, taskToUnmark));

        case MarkCommand.COMMAND_WORD:
        case MarkCommand.COMMAND_WORD_FAST:
            ReadOnlyTask taskToMark = undoHistory.getUnmarkHistory().pop();
            history.addToMarkHistory(taskToMark);
            model.markTask(taskToMark);
            fullMessage = MESSAGE_SUCCESS.concat(MarkCommand.MESSAGE_MARK_TASK_SUCCESS);
            return new CommandResult(String.format(fullMessage, taskToMark));

        default:
            String message = MESSAGE_INVALID_PREVIOUS_COMMAND.concat(previousCommandWord);
            return new CommandResult(message);
        }
    }
}
```
###### \java\teamthree\twodo\logic\commands\SaveCommand.java
``` java
// Saves TaskList to the specified directory
public class SaveCommand extends Command {

    public static final String COMMAND_WORD = "save";
    public static final String COMMAND_WORD_FAST = "-s";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Save the TaskList created with 2Do into"
            + "FILE_PATH/FILENAME.xml\n" + "Example: (WINDOWS) C:/Users/Desktop/2Do.xml\n"
            + " Example: (MAC) /User/Username/Desktop/2Do.xml\n";

    public static final String MESSAGE_SUCCESS = "File is successfully saved to: %1$s\n";
    public static final String MESSAGE_INVALID_PATH = "File Path %1$s is invalid\n";
    public static final String MESSAGE_FAILURE = "Failed to save file to %1$s\n";
    private static final String XML = ".xml";
    public final String filePath;

    public SaveCommand(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (!isXml(filePath)) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
        try {
            Paths.get(filePath);
            EventsCenter.getInstance().post(new TaskListFilePathChangedEvent(filePath));
            model.saveTaskList();
            return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
        } catch (InvalidPathException e) {
            throw new CommandException(String.format(MESSAGE_INVALID_PATH, filePath));
        }
    }

    private boolean isXml(String filePath) {
        return filePath.endsWith(XML);
    }
}
```
###### \java\teamthree\twodo\logic\commands\UndoCommand.java
``` java
// Undoes the previous command by the user
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_WORD_FAST = "u";
    public static final String MESSAGE_SUCCESS = "Successfully undid command!!!\n";
    public static final String MESSAGE_NO_HISTORY = "Failed to undo: You have not yet entered any commands. ";
    public static final String MESSAGE_INVALID_PREVIOUS_COMMAND = "Failed to undo: Invalid previous command ";

    public static final String DELETE_TAG = "tag";

    public static final String MESSAGE_ADD_TAG_SUCCESS = "Added Tag ";

    private static String fullMessage;

    @Override
    public CommandResult execute() throws CommandException {
        if (history.getUserInputHistory().isEmpty()) {
            return new CommandResult(MESSAGE_NO_HISTORY);
        }

        CommandResult undoResult = null;
        try {
            undoResult = processUserInput();
        } catch (DuplicateTaskException e) {
            throw new CommandException(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (ParseException e) {
            assert false : "The Command is invalid";
        } catch (IllegalValueException e) {
            assert false : "The Value is illegal";
        }
        return undoResult;
    }

    private CommandResult processUserInput() throws TaskNotFoundException, IllegalValueException, CommandException {
        final String previousCommandWord = history.getUserInputHistory().pop();
        undoHistory.addToUserInputHistory(previousCommandWord); //Save CommandWord for RedoCommand

        //Process previous Command Word and undo the command
        switch (previousCommandWord) {

        case AddCommand.COMMAND_WORD:
        case AddCommand.COMMAND_WORD_QUICK:
        case AddCommand.COMMAND_WORD_FAST:
            return undoAddCommand();

        case EditCommand.COMMAND_WORD:
            return undoEditCommand();

        case DeleteCommand.COMMAND_WORD_QUICK:
        case DeleteCommand.COMMAND_WORD_FAST:
        case DeleteCommand.COMMAND_WORD_SHORT:
        case DeleteCommand.COMMAND_WORD:
            return undoDeleteCommand();

        case DELETE_TAG:
            return undoDeleteTagCommand();

        case ClearCommand.COMMAND_WORD:
            return undoClearCommand();

        case MarkCommand.COMMAND_WORD:
        case MarkCommand.COMMAND_WORD_FAST:
            return undoMarkCommand();

        case UnmarkCommand.COMMAND_WORD:
        case UnmarkCommand.COMMAND_WORD_FAST:
            return undoUnmarkCommand();

        default:
            //For Previous Command like find, list which cannot be undone
            String message = MESSAGE_INVALID_PREVIOUS_COMMAND.concat(previousCommandWord);
            return new CommandResult(message);
        }
    }

    /**
     * Mark task that was marked and store {@code taskToUnmark} for RedoCommand
     * @return  a Command Result to inform users of that the Unmark command has been undone
     * @throws TaskNotFoundException if the task to be marked cannot be found in the model
     */
    private CommandResult undoUnmarkCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToMark = history.getUnmarkHistory().pop(); //Retrieve Task to mark
        undoHistory.addToMarkHistory(taskToMark); //Store Task for RedoCommand
        model.markTask(taskToMark);
        fullMessage = MESSAGE_SUCCESS.concat(MarkCommand.MESSAGE_MARK_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToMark));
    }

    /**
     * Unmark task that was marked and store {@code taskToUnmark} for RedoCommand
     * @return  a Command Result to inform users of that the unmark command has been undone
     * @throws TaskNotFoundException if the task to be unmarked cannot be found in the model
     */
    private CommandResult undoMarkCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToUnmark = history.getMarkHistory().pop();
        undoHistory.addToUnmarkHistory(taskToUnmark); //Store Task for RedoCommand
        model.unmarkTask(taskToUnmark);
        fullMessage = MESSAGE_SUCCESS.concat(UnmarkCommand.MESSAGE_UNMARK_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToUnmark));
    }

    /**
     * Restores Original TaskLIst before Clear Command
     * @return  a Command Result to inform users of that the clear command has been undone
     */
    private CommandResult undoClearCommand() {
        ReadOnlyTaskList taskBook = history.getClearHistory().pop();
        model.resetData(taskBook);
        fullMessage = MESSAGE_SUCCESS.concat("Restored TaskList");
        return new CommandResult(fullMessage);
    }

    /**
     * Add back Deleted Tag and Stores {@code tag} and {@code taskList} for RedoCommand
     * @return  a Command Result to inform users of that the delete Tag command has been undone
     */
    private CommandResult undoDeleteTagCommand() {
        ReadOnlyTaskList taskList = history.getDelTagHistory().pop();
        Tag tag = history.getTagHistory().pop();
        undoHistory.addToDelTagHistory(new TaskList(model.getTaskList())); //Store current model b4 tag is added
        undoHistory.addToTagHistory(tag); //Store Tag for RedoCommand
        model.resetData(taskList);
        fullMessage = MESSAGE_SUCCESS.concat(MESSAGE_ADD_TAG_SUCCESS + tag.tagName);
        return new CommandResult(fullMessage);
    }

    /**
     * Add back Deleted Task and Stores {@code taskToAdd} for RedoCommand
     * @return a Command Result to inform users of that the delete command has been undone
     * @throws DuplicateTaskException if there is a duplicate of the deleted task to be added back into the model
     */
    private CommandResult undoDeleteCommand() throws DuplicateTaskException {
        ReadOnlyTask taskToAdd = history.getDeleteHistory().pop();
        undoHistory.addToAddHistory(taskToAdd); //Store Task for RedoCommand
        model.addTask(taskToAdd);
        fullMessage = MESSAGE_SUCCESS.concat(AddCommand.MESSAGE_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToAdd));
    }

    /**
     * Restores back original Task and Stores {@code originalTask} and {@code edittedTask} for RedoCommand
     * @return  a Command Result to inform users of that the edit command has been undone
     * @throws DuplicateTaskException if the edited task already exists in the model
     * @throws TaskNotFoundException if the target task to be edited is not found in the model
     */
    private CommandResult undoEditCommand() throws DuplicateTaskException, TaskNotFoundException {
        ReadOnlyTask originalTask = history.getBeforeEditHistory().pop();
        ReadOnlyTask edittedTask = history.getAfterEditHistory().pop();
        saveTargetTaskForRedo(originalTask);
        saveEditedTargetTaskForRedo(edittedTask);
        model.updateTask(edittedTask, originalTask);
        fullMessage = MESSAGE_SUCCESS.concat(EditCommand.MESSAGE_EDIT_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, edittedTask));
    }

    /**
     * Store Target Task to be edited during RedoCommand to reverse action of this current UndoCommand
     * Create a new Task/TaskWithDeadline depending on whether the task has deadline
     * @param originalTask must not be null
     */
    private void saveTargetTaskForRedo(ReadOnlyTask originalTask) {
        assert originalTask != null;
        if (originalTask.getDeadline().isPresent()) {
            undoHistory.addToAfterEditHistory(new TaskWithDeadline(originalTask));
        } else {
            undoHistory.addToAfterEditHistory(new Task(originalTask));
        }
    }

    /**
     * Store Editted Task that should be in model after RedoCommand.
     * Create a new Task/TaskWithDeadline depending on whether the task has deadline
     * @param edittedTask must not be null
     */
    private void saveEditedTargetTaskForRedo(ReadOnlyTask edittedTask) {
        assert edittedTask != null;
        if (edittedTask.getDeadline().isPresent()) {
            undoHistory.addToBeforeEditHistory(new TaskWithDeadline(edittedTask));
        } else {
            undoHistory.addToBeforeEditHistory(new Task(edittedTask));
        }
    }

    /**
     * Deleting the task added and stores {@code taskToDelete} for RedoCommand
     * @return a Command Result to inform users of that the add command has been undone
     * @throws TaskNotFoundException if the task to be deleted cannot be found in the model
     */
    private CommandResult undoAddCommand() throws TaskNotFoundException {
        ReadOnlyTask taskToDelete = history.getAddHistory().pop();
        assert taskToDelete != null;

        undoHistory.addToDeleteHistory(taskToDelete); //Store Task for RedoCommand
        model.deleteTask(taskToDelete);
        fullMessage = MESSAGE_SUCCESS.concat(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS);
        return new CommandResult(String.format(fullMessage, taskToDelete));
    }
}
```
###### \java\teamthree\twodo\logic\parser\LoadCommandParser.java
``` java
/**
 * Parses input arguments and creates a new LoadCommand object
 *
 * @throws ParseException
 *             if the user input does not conform to the expected format
 */
public class LoadCommandParser {
    public LoadCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        File file = new File(trimmedArgs);
        if (!file.isDirectory()) {
            return new LoadCommand(args.trim());
        } else {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, LoadCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\teamthree\twodo\logic\parser\SaveCommandParser.java
``` java
/**
 * Parses input arguments and creates a new LoadCommand object
 *
 * @throws ParseException
 *             if the user input does not conform to the expected format
 */
public class SaveCommandParser {
    public SaveCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        File file = new File(trimmedArgs);
        if (!file.isDirectory()) {
            return new SaveCommand(args.trim());
        } else {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\teamthree\twodo\logic\UndoCommandHistory.java
``` java
// Stores the history of Undo commands executed.
public class UndoCommandHistory {
    private Stack<String> userInputHistory;
    private Stack<ReadOnlyTask> beforeEditHistory;
    private Stack<ReadOnlyTask> afterEditHistory;
    private Stack<ReadOnlyTask> deleteHistory;
    private Stack<ReadOnlyTask> addHistory;
    private Stack<ReadOnlyTask> markHistory;
    private Stack<ReadOnlyTask> unmarkHistory;
    private Stack<ReadOnlyTask> undoHistory;
    private Stack<ReadOnlyTaskList> delTagHistory;
    private Stack<Tag> tagHistory;

    public UndoCommandHistory() {
        beforeEditHistory = new Stack<ReadOnlyTask>();
        afterEditHistory = new Stack<ReadOnlyTask>();
        addHistory = new Stack<ReadOnlyTask>();
        deleteHistory = new Stack<ReadOnlyTask>();
        markHistory = new Stack<ReadOnlyTask>();
        unmarkHistory = new Stack<ReadOnlyTask>();
        userInputHistory = new Stack<String>();
        undoHistory = new Stack<ReadOnlyTask>();
        delTagHistory = new Stack<ReadOnlyTaskList>();
        tagHistory = new Stack<Tag>();
    }

    /**
     * Appends {@code userInput} to the list of user input entered.
     * @throws ParseException
     */
    public void addToUserInputHistory(String userInput) throws ParseException {
        requireNonNull(userInput);
        String commandWord = getCommandWordFromInput(userInput);
        getUserInputHistory().push(commandWord);
    }

    /**
     * Appends {@code task} to the list of task before edits entered.
     */
    public void addToBeforeEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        beforeEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of task after edits entered.
     */
    public void addToAfterEditHistory(ReadOnlyTask task) {
        requireNonNull(task);
        afterEditHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of added tasks entered.
     */
    public void addToAddHistory(ReadOnlyTask task) {
        requireNonNull(task);
        addHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of deleted tasks entered.
     */
    public void addToDeleteHistory(ReadOnlyTask task) {
        requireNonNull(task);
        deleteHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of marked tasks entered.
     */
    public void addToMarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        markHistory.push(task);
    }

    /**
     * Appends {@code task} to the list of unmarked tasks entered.
     */
    public void addToUnmarkHistory(ReadOnlyTask task) {
        requireNonNull(task);
        unmarkHistory.push(task);
    }

    public void addToUndoHistory(ReadOnlyTask task) {
        requireNonNull(task);
        undoHistory.push(task);
    }

    public void addToDelTagHistory(ReadOnlyTaskList taskList) {
        requireNonNull(taskList);
        delTagHistory.push(taskList);
    }

    public void addToTagHistory(Tag tag) {
        requireNonNull(tag);
        tagHistory.push(tag);
    }


    public Stack<String> getUserInputHistory() {
        requireNonNull(userInputHistory);
        return userInputHistory;
    }

    public Stack<ReadOnlyTask> getBeforeEditHistory() {
        requireNonNull(beforeEditHistory);
        return beforeEditHistory;
    }

    public Stack<ReadOnlyTask> getAfterEditHistory() {
        requireNonNull(afterEditHistory);
        return afterEditHistory;
    }

    public Stack<ReadOnlyTask> getAddHistory() {
        requireNonNull(addHistory);
        return addHistory;
    }

    public Stack<ReadOnlyTask> getDeleteHistory() {
        requireNonNull(deleteHistory);
        return deleteHistory;
    }

    public Stack<ReadOnlyTask> getMarkHistory() {
        requireNonNull(markHistory);
        return markHistory;
    };

    public Stack<ReadOnlyTask> getUndokHistory() {
        requireNonNull(undoHistory);
        return undoHistory;
    };

    public Stack<ReadOnlyTask> getUnmarkHistory() {
        requireNonNull(unmarkHistory);
        return unmarkHistory;
    }

    public Stack<ReadOnlyTaskList> getDelTagHistory() {
        requireNonNull(delTagHistory);
        return delTagHistory;
    }

    public Stack<Tag> getTagHistory() {
        requireNonNull(tagHistory);
        return tagHistory;
    }

    private String getCommandWordFromInput(String userInput) throws ParseException {
        final Matcher matcher = Parser.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        return commandWord;
    }
}
```
###### \java\teamthree\twodo\storage\StorageManager.java
``` java
    public void setTaskListFilePath(String filePath) throws IOException {
        taskListStorage.setTaskListFilePath(filePath);
        config.setTaskListFilePath(filePath);
        ConfigUtil.saveConfig(config, Config.getDefaultConfigFile());
        raise(new TaskListStorageChangedEvent(filePath));
    }

    @Override
    public Optional<ReadOnlyTaskList> readTaskList() throws DataConversionException, IOException {
        return readTaskList(taskListStorage.getTaskListFilePath());
    }

    @Override
    public Optional<ReadOnlyTaskList> readTaskList(String filePath) throws DataConversionException, IOException {
        logger.fine("Attempting to read data from file: " + filePath);
        return taskListStorage.readTaskList(filePath);
    }

    @Override
    public void saveTaskList(ReadOnlyTaskList taskList) throws IOException {
        saveTaskList(taskList, taskListStorage.getTaskListFilePath());
    }

    @Override
    public void saveTaskList(ReadOnlyTaskList taskList, String filePath) throws IOException {
        logger.fine("Attempting to write to data file: " + filePath);
        taskListStorage.saveTaskList(taskList, filePath);
    }

    public void saveNotifiedTasks(HashSet<ReadOnlyTask> notified, String filePath) throws IOException {
        logger.fine("Attempting to write to data file: " + filePath);
    }

    @Override
    @Subscribe
    public void handleTaskListChangedEvent(TaskListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveTaskList(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    @Subscribe
    private void handleTaskListFilePathChangedEvent(TaskListFilePathChangedEvent event) throws CommandException {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local filePath changed, saving to config"));
        try {
            setTaskListFilePath(event.filePath);
        } catch (IOException e) {
            throw new CommandException(String.format(SaveCommand.MESSAGE_INVALID_PATH, event.filePath));
        }
    }

    @Subscribe
    public void handleLoadCommandExecutedEvent(LoadCommandExecutedEvent event) throws CommandException {
        logger.info(
                LogsCenter.getEventHandlingLogMessage(event, "Load command executed, saving new filepath to config"));
        try {
            Optional<ReadOnlyTaskList> loadedTaskList;
            if ((loadedTaskList = readTaskList(event.filePath)).isPresent()) {
                setTaskListFilePath(event.filePath);
                raise(new LoadNewModelEvent(loadedTaskList.get()));
            }
        } catch (IOException e) {
            throw new CommandException(String.format(SaveCommand.MESSAGE_INVALID_PATH, event.filePath));
        } catch (DataConversionException e) {
            throw new CommandException(Messages.MESSAGE_LOAD_FAILED);
        }
    }
}
```
###### \java\teamthree\twodo\ui\CommandBox.java
``` java
    @FXML
    private void handleKeyPressed(KeyEvent e) {
        if (e.getCode().equals(KeyCode.UP)) {
            accessPreviousCommand();
        } else if (e.getCode().equals(KeyCode.DOWN)) {
            accessNextCommand();
        }
    }

    // Displays the previous command input on the command box if it is available
    private void accessPreviousCommand() {
        if (index > 0) {
            index--;
            commandTextField.clear();
            commandTextField.appendText(previousUserInput.get(index));
        }
    }

    private void accessNextCommand() {
        if (index < previousUserInput.size() - 1) {
            index++;
            commandTextField.clear();
            commandTextField.appendText(previousUserInput.get(index));
        }
    }
    public void setPreviousUserInput(ArrayList<String> newUserInputList) {
        previousUserInput = newUserInputList;
    }

    //Sets the command box style to indicate a successful command.
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
    }

    //Sets the command box style to indicate a failed command.
    private void setStyleToIndicateCommandFailure() {
        ObservableList<String> styleClass = commandTextField.getStyleClass();

        if (styleClass.contains(ERROR_STYLE_CLASS)) {
            return;
        }

        styleClass.add(ERROR_STYLE_CLASS);
    }

    public void handleNewUserInputEvent(NewUserInputEvent e) {
        this.setPreviousUserInput(e.userInput);
        index = e.userInput.size();
    }

}
```
###### \java\teamthree\twodo\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleTaskListStorageChangedEvent(TaskListStorageChangedEvent e) {
        logger.info(LogsCenter.getEventHandlingLogMessage(e, "Task List saved to " + e.filePath));
        setSaveLocation(e.filePath);
    }
}
```
###### \java\teamthree\twodo\ui\UiManager.java
``` java
    @Subscribe
    public void handleNewUserInputEvent(NewUserInputEvent e) {
        mainWindow.getCommandBox().handleNewUserInputEvent(e);
    }

}
```
